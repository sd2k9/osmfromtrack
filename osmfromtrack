#!/usr/bin/env python
# -*- coding: utf-8 -*-
# file name: ''osmfromtrack''
#   project: osmfromtrack
#  function: Download OSM data around a GPX track
#
#      created: 2012-08-18
#  last change: $LastChangedRevision$
#
# Download OSM data from within a coordinate box or gpx track
# Copyright (C) 2012, 2013 Robert Lange (robert.lange@s1999.tu-chemnitz.de)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#



# *** Import modules
# To control output level easily
import logging
# Argument parser
import argparse
# Regular Expressions
import re
# OS operation
import os
# Spawn sub-process
import subprocess
# Fetching OSM Data
import urllib2


# ******************************************************************************
# *** Global settings as dictionary
opts = { # URL of the XAPI to fetch OSM data from, with its coords west,south,east,north
        # Will be used with format()
        # Outdated and not working anymore?
        # 'xapi_url': 'http://open.mapquestapi.com/xapi/api/0.6/map?bbox={west:f},{south:f},{east:f},{north:f}',
        'xapi_url': 'http://overpass.osm.rambler.ru/cgi/xapi?map?bbox={west:f},{south:f},{east:f},{north:f}',
        # Test mode - only echo commands, will be set by command line
        'test': False,
        # Fetch OSM data - can be unset by command line
        'osm': True,
        # Create Topographic map - can be unset by command line
        'topo': True,
        # Compress files - can be unset by command line
        'compress': True,
        # Default hgt cache directory - can be changed by command line
        'topo_hgtcache_dir': os.path.expanduser("~") + "/.cache/hgt",

        # Command for Topographic Map creation: phyghtmap
        'topo_cmd': 'phyghtmap',
        # Default options for phyghtmap
        'topo_opts': [ "--step=50",
                      "--line-cat=400,100", "--jobs=2", "--viewfinder-mask=1",
                       "--verbatim-output-name" ],    # phyghtmap improvement not to mangle the file name
        # Custom hgt cache directory, will be used with format()
        'topo_opts_hgtcache': '--hgtdir={dir:s}',
        # Area to process, will be used with format()
        'topo_opts_area': '--area={west:f}:{south:f}:{east:f}:{north:f}',
        # Output base file name, will be used with format()
        'topo_opts_output': '-o{outfile:s}',

        # Command for compression: xz
        'compress_cmd': 'xz',
        # Default options for compress_cmd
        'compress_opts': [ ], # none

        # Invoke etrex30 afterwards when not None
        # contains title and shorttitle as array - set by command line
        'etrex_title_shorttitle': None,
        # etrex30 executable
        'etrex_cmd': 'etrex30',
       }

# Provide logging shortcuts
pinfo  = logging.info
pwarn  = logging.warning
perror = logging.error


# ******************************************************************************
# *** Exception Objects - they should be improved to also include the error reason

class OutputFileExists(BaseException):
    """Exception Class for existing output file
    """
    pass
class ExecuteCommandFailed(BaseException):
    """Exception Class for failed program execution
    """
    pass


# ********************************************************************************
# *** Objects

class Coord():
   """GPX coordinates, consisting of longitude and latitude
   """
   # C'Tor with arguments longitude and latitude
   def __init__(self, lat = 0, lon = 0):
       self.lat = lat
       self.lon = lon
   # Latitude
   # lat
   # Longitude
   # lon

class ExecTopoCmd():
   """Execute the topographic map creation tool

   Should be used together with the "with" statement:
        with ExecTopoCmd() as topo_tool:
            pass
   Why "with"? Just for fun and playing around with it ^_^

   C'tor Arguments: pos1, pos2 - Point1 and Point 2 of coordinates (class Coord)
             outfile - Output file name, to write the OSM data to

   Return: Nothing
   """
   # C'Tor with arguments
   def __init__(self, pos1, pos2, outfile):
       # Preprocessing - match coords to box boundaries
       (self._west, self._east, self._north, self._south) = coord_order(pos1, pos2)
       # And store filebase
       self._outfile = outfile

   # Start of with processing
   def __enter__(self):
       # Call to  phyghtmap with default arguments (see opts) and the
       # --area=LEFT:BOTTOM:RIGHT:TOP and -o output_base

       # Then execute it
       try:
           execute_cmd(opts['topo_cmd'], opts['topo_opts'] +
              [ opts['topo_opts_area'].format(west=self._west, east=self._east, north=self._north, south=self._south), 
                opts['topo_opts_hgtcache'].format(dir=opts['topo_hgtcache_dir']),
                opts['topo_opts_output'].format(outfile=self._outfile) ]
              )
       except ExecuteCommandFailed:
           raise    # Error already printed, that's it for us
       except:   # Other error
           perror("   Execution failed!")
           raise

       return self

   # End of with processing - kinda destructor
   def __exit__(self, type, value, traceback):
       pass








# ******************************************************************************
# *** Functions

def relax_float(string):
   """A relaxed float representation, which also understands "," as separator

   For example, both values are equally valid and have the same value:
   123.456 == 123,456

   Return: Float or raises an ArgumentTypeError
   """
   # First try the replacement (in case it's necessary)
   rstring = re.sub(',', '.', string)
   try:  # Now try the conversion
     val = float(rstring)
   except:   # Error, we have failed
       msg = "{0} is no float value".format(string)
       raise argparse.ArgumentTypeError(msg)
   # else we have succeeded
   return val

def execute_cmd(cmd, args):
    """Execute the given command and raises an ExecuteCommandFailed upon failure

    Argument: Command to execute
              Its arguments as list

    Return: Nothing
    """

    # Echo
    pinfo("   Executing " + cmd + " " + " ".join(args) )

    # Execute and print output
    if not opts['test']:  # Not in testmode
        try:
            retcode = subprocess.call([cmd] + args, shell=False)
            if retcode < 0:
                perror("   cmd {0} was terminated by signal {1} ".format(cmd, str(-retcode)))
                raise ExecuteCommandFailed()
            elif retcode > 0:
                perror("   cmd {0} retunred error code {1} ".format(cmd, str(retcode)))
                raise ExecuteCommandFailed()
        except OSError as e:
            perror("   cmd {0} execution failed: {1}".format(cmd, str(e)))
            raise ExecuteCommandFailed()
        except:
            raise   # Other errors are passed further

    # Done
    return


def coord_order(pos1, pos2):
    """Sort the coordinates into the right order

    Arguments: pos1, pos2 - Point1 and Point 2 of coordinates (class Coord)

    Return: Coordinates sorted as
            (west, east, north, south)
    """
    # Preprocessing - match coords to box boundaries
    # west/east
    if pos1.lon > pos2.lon:
        west = pos2.lon
        east = pos1.lon
    else:
        west = pos1.lon
        east = pos2.lon
    # north/south
    if pos1.lat > pos2.lat:
        north = pos1.lat
        south = pos2.lat
    else:
        north = pos2.lat
        south = pos1.lat
    return (west, east, north, south)

def get_osm_data(pos1, pos2, outfile):
    """Download OSM data from a box into a file

    Arguments: pos1, pos2 - Point1 and Point 2 of coordinates (class Coord)
              outfile - Output file name, to write the OSM data to

    Return: Output file name (can be modified by compression)
    """
    # Manual data fetching with OSM (X)API:
    # - Example export from www.openstreetmap.org
    #        47.1916
    # 9.8237		9.8746
    # 	47.1423
    #
    # - bbox = left,down,right,up
    #
    # API - Data identical
    # curl --location --globoff -o map-osm-api.osm  'http://api.openstreetmap.org/api/0.6/map?bbox=9.8237,47.1423,9.8746,47.1916'
    #
    # XAPI - Seems to be reordered compared to API result, but content-wise identical
    # curl --location --globoff -o map-osm-xapi.osm  'http://open.mapquestapi.com/xapi/api/0.6/map?bbox=9.8237,47.1423,9.8746,47.1916'

    # Preprocessing - match coords to box boundaries
    (west, east, north, south) = coord_order(pos1, pos2)
    # The URL constructed
    url_str = opts['xapi_url'].format(west=west, east=east, north=north, south=south)

    # Check for existing outfile - Attention race condition because of later open!
    if os.path.isfile(outfile):
        perror("File " + outfile + " exists already - Aborting")
        raise OutputFileExists

    # Open output file
    try:
        # Open output file - binary write
        if not opts['test']:  # Not in testmode
            out = open(outfile, 'wb')
    except:
        perr('Failing to open output file ' + outfile)
        raise


    try:
        # Open the URL
        pinfo("Fetching OSM data from URL\n   " + url_str)
        pinfo("   and writing it to file " + outfile)
        pinfo("   This will take a while ...")
        if not opts['test']:  # Not in testmode
              url = urllib2.urlopen(url_str)
    except:
        perror('Opening the XAPI-URL failed: ' + url_str )
        raise

    try:
        # Write to file - with nice progress bar thanks to
        # http://stackoverflow.com/questions/22676/how-do-i-download-a-file-over-http-using-python
        if not opts['test']:  # Not in testmode
            out.write(url.read())
            # Progress bar not working as expected because of chunked transfer
            # meta = url.info()
            # print meta
            # file_size = int(meta.getheaders("Content-Length")[0])
            # print file_size
            # return
            # pinfo("   Downloading: {0:s} Bytes: {1:s}".format(file_name, file_size) )
            # file_size_dl = 0
            # block_sz = 8192
            # while True:
            #     buffer = url.read(block_sz)
            #     if not buffer:
            #         break
            # file_size_dl += len(buffer)
            # out.write(buffer)
            # status = r"%10d  [%3.2f%%]" % (file_size_dl, file_size_dl * 100. / file_size)
            # status = status + chr(8)*(len(status)+1)
            # pinfo("   " + status)
    except:
        perror('Reading data and writing to the file failed!')
        raise

    # Cleanup
    if not opts['test']:  # Not in testmode
        url.close()
        out.close()

    # Do compression, when requested
    routfile = compress_file(outfile)

    # Over and out
    pinfo("   Done!")
    return routfile

def compress_file(cfile):
    """Compress the specified file when enabled in options

    Arguments: cfile - file to compress in-place

    Return: Output file name (can be modified by compression)
    """

    if not opts['compress']:
        return cfile                         # No compression requested

    # Then execute it
    try:
        execute_cmd(opts['compress_cmd'],
                    opts['compress_opts'] + [ cfile ] )
    except ExecuteCommandFailed:
        raise    # Error already printed, that's it for us
    except:   # Other error
        perror("   Execution failed!")
        raise
    return cfile + ".xz"


def get_topo_data(pos1, pos2, outfile):
    """Create OSM Topographic data from a box into a file

    Arguments: pos1, pos2 - Point1 and Point 2 of coordinates (class Coord)
              outfile - Output file name

    Return: Output file name (can be modified by compression)
    """

    # Call Sub-Program with the help of a context manager
    pinfo("Creating topographic map data with " + opts['topo_cmd'])
    try:
        with ExecTopoCmd(pos1, pos2, outfile) as topo_tool:
            pass
    except ExecuteCommandFailed:
        # Already consumed, no more printing
        return None
    except:
        perror("   Execution failed!")
        raise

    # Check that output file got created
    if not opts['test']:  # Not in testmode
        if not os.path.isfile(outfile):
            perror("Expected output file " + outfile + " did not got created - Aborting")
            raise OutputFilekNotCreated

    # Do compression, when requested
    routfile = compress_file(outfile)

    # Over and out
    pinfo("   Done!")
    return routfile


def invoke_etrex(title, shorttitle, osm, topo):
    """Invokes etrex30 executable for the created files

    Arguments: title      - Map Title, see etrex30
               shorttitle - Map Short Title, see etrex30
               osm        - Filename OSM Data
               topo       - Filename Topographic OSM Data; None when not availabe

    Return: Nothing
    """

    pinfo("Invoking etrex to put files an Garmim device")

    # Build option array
    etrex_opts = []
    if topo is None:
        etrex_opts.append("putosm")  # Only OSM
    else:
        etrex_opts.append("puttopo")  # OSM and Topo

    # OSM Data
    etrex_opts.append(osm)
    if topo is not None:
        etrex_opts.append(topo)        # Also add Topo
    # Title names
    etrex_opts.extend([ title, shorttitle ] )

    # Execute it
    execute_cmd(opts['etrex_cmd'], etrex_opts )

    # Over and out
    pinfo("   Done!")
    return

# ********************************************************************************

# *** Main Program
def main():

    # *** Command line parsing
    # cmd_usage="usage: %prog [options] args"
    # For now, just fetch a rectangle by its coordinates
    cmd_desc ="""Download OSM data from a coordinate box
Supply with two set of coorinates (like from Google Map's LatLng marker)
and the box will be fetched from OSM.
When not disabled, also the topographic data will be created
Example: %(prog)s data 61,001 22,758 60.948 22.871
         Yes, both English as well as German notation is allowed"""
    # cmd_desc ="""osmfromtrack - Download OSM data around a GPX track"""
    cmd_version="%(prog)s " + __version__
    cmd_parser = argparse.ArgumentParser(description=cmd_desc,
                 formatter_class=argparse.RawDescriptionHelpFormatter)  # With pre-formatted description
    cmd_parser.add_argument('filebase', help='Output file name base - no suffix please')
    cmd_parser.add_argument('latitude1', type=relax_float, help='Latitude of first point')
    cmd_parser.add_argument('longitude1', type=relax_float, help='Longitude of first point')
    cmd_parser.add_argument('latitude2', type=relax_float, help='Latitude of second point')
    cmd_parser.add_argument('longitude2', type=relax_float, help='Longitude of second point')
    cmd_parser.add_argument('-V', '--version', action='version', version=cmd_version)
    cmd_parser.add_argument('--quiet', '-q', dest='quiet', action='store_true',
                        default=False, help='quiet output')
    cmd_parser.add_argument('--test', '--dry-run', '-t', dest='test', action='store_true',
                        default=False, help='Test mode - only echo commands')
    cmd_parser.add_argument('--no-osm', dest='osm', action='store_false',
                        default=True, help='Do not download OSM data')
    cmd_parser.add_argument('--no-topo', dest='topo', action='store_false',
                        default=True, help='Do not create a topographic map overlay')
    cmd_parser.add_argument('--no-compress', dest='compress', action='store_false',
                        default=True, help='Do not compress output files with ' + opts['compress_cmd'] )
    cmd_parser.add_argument('--hgtdir', dest='hgtdir', action='store',
                        default=None, help='Change hgt cache directory for topographic map overlay, '
                                      'defaults to ' + opts['topo_hgtcache_dir'],
                            metavar="DIRECTORY")
    cmd_parser.add_argument('-e', '--etrex', '--etrex30', dest='etrex', action='store', nargs=2,
                            default=None,
                            help='Invoke etrex30 with argument osm or topo to put the created files '
                            'on a Garmin eTrex30 device. '
                            'First value is title, second value is shorttitle. See etrex30 help',
                            metavar="VAL")
    # Parse - abort on failure
    cmd_line = cmd_parser.parse_args()

    # Setup logging: Show only from warnings when being QUIET
    logging.basicConfig(level=logging.WARNING if cmd_line.quiet else logging.INFO,
                    format="%(message)s")
    # Set test mode
    opts['test'] = cmd_line.test
    # (Un)Set OSM download
    opts['osm'] = cmd_line.osm
    # (Un)Set topo map creation
    opts['topo'] = cmd_line.topo
    # (Un)Set topo map creation
    opts['compress'] = cmd_line.compress
    # Set hgt cache dir
    if cmd_line.hgtdir:
        opts['topo_hgtcache_dir'] = cmd_line.hgtdir
    # Set etrex30 arguments
    if cmd_line.etrex:
        opts['etrex_title_shorttitle'] = cmd_line.etrex

    # Get the data from the OSM XAPI
    filename_osm=None
    if opts['osm']:
        filename_osm = get_osm_data( Coord(cmd_line.latitude1, cmd_line.longitude1),
                  Coord(cmd_line.latitude2, cmd_line.longitude2),
                  cmd_line.filebase+".osm")

    # Also fetch the SRTM data when not disabled
    filename_topo=None
    if opts['topo']:
        filename_topo = get_topo_data( Coord(cmd_line.latitude1, cmd_line.longitude1),
                  Coord(cmd_line.latitude2, cmd_line.longitude2),
                  cmd_line.filebase+".topo.osm")

    # Invoke etrex30 when requested
    if opts['etrex_title_shorttitle']:
        # Check for all combinations
        if not opts['osm']:
            # noosm, * - Not allowed
            pwarn("OSM data creation disabled, therefore no garmin Download possible.")
            pwarn("    Ignoring option --etrex")
        elif opts['osm'] and (not opts['topo']):
            # osm, notopo - No Topographic Data
            invoke_etrex( title=opts['etrex_title_shorttitle'][0],
                          shorttitle=opts['etrex_title_shorttitle'][1],
                          osm=filename_osm,
                          topo=None)
        elif opts['osm'] and opts['topo']:
            # osm, topo - Full data available
            invoke_etrex( title=opts['etrex_title_shorttitle'][0],
                          shorttitle=opts['etrex_title_shorttitle'][1],
                          osm=filename_osm,
                          topo=filename_topo)
        else:
            perror("Something wrent wrong, this path should have been a non-entry path")
            raise AssertionError

    # All done, over and out
    pinfo("All Done!")
    return 0


# *** Call Main program
__version__ = filter(str.isdigit, "$LastChangedRevision$")
if not __version__:
    __version__='DEV'
if __name__ == "__main__":
    main()

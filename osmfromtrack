#!/usr/bin/env python
# -*- coding: utf-8 -*-
# file name: ''osmfromtrack''
#   project: osmfromtrack
#  function: Download OSM data around a GPX track
#
#      created: 2012-08-18
#  last change: $LastChangedRevision$
#
# Copyright (C) 2012 Robert Lange (robert.lange@s1999.tu-chemnitz.de)
# Licensed under the GNU General Public License, version 2
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
#



# *** Import modules
# To control output level easily
import logging
# Argument parser
import argparse
# Regular Expressions
import re
# OS operation
import os
# Spawn sub-process
import subprocess
# Fetching OSM Data
import urllib2


# ******************************************************************************
# *** Global settings as dictionary
opts = { # URL of the XAPI to fetch OSM data from, with its coords west,south,east,north
        # Will be used with format()
        'xapi_url': 'http://open.mapquestapi.com/xapi/api/0.6/map?bbox={west:f},{south:f},{east:f},{north:f}',
        # Test mode - only echo commands, will be set by command line
        'test': False,
        # Create Topographic map also - can be unset by command line
        'topo': True,
        # Default hgt cache directory - can be changed by command line
        'topo_hgtcache_dir': os.path.expanduser("~") + "/.cache/hgt",

        # Command for Topographic Map creation: phyghtmap
        'topo_cmd': 'phyghtmap',
        # Default options for phyghtmap
        'topo_opts': [ "--step=50",
                      "--line-cat=400,100", "--jobs=2", "--viewfinder-mask=1",
                      "--gzip=9" ],
        # Custom hgt cache directory, will be used with format()
        'topo_opts_hgtcache': '--hgtdir={dir:s}',
        # Area to process, will be used with format()
        'topo_opts_area': '--area={west:f}:{south:f}:{east:f}:{north:f}',
        # Output base file name, will be used with format()
        'topo_opts_output': '-o{outbase:s}',
       }

# Provide logging shortcuts
pinfo  = logging.info
pwarn  = logging.warning
perror = logging.error


# ******************************************************************************
# *** Exception Objects - they should be improved to also include the error reason

class OutputFileExists(BaseException):
    """Exception Class for existing output file
    """
    pass
class ExecuteCommandFailed(BaseException):
    """Exception Class for failed program execution
    """
    pass


# ********************************************************************************
# *** Objects

class Coord():
   """GPX coordinates, consisting of longitude and latitude
   """
   # C'Tor with arguments longitude and latitude
   def __init__(self, lat = 0, lon = 0):
       self.lat = lat
       self.lon = lon
   # Latitude
   # lat
   # Longitude
   # lon

class ExecTopoCmd():
   """Execute the topographic map creation tool

   Should be used together with the "with" statement:
        with ExecTopoCmd() as topo_tool:
            pass
   Why "with"? Just for fun and playing around with it ^_^

   C'tor Arguments: pos1, pos2 - Point1 and Point 2 of coordinates (class Coord)
             outbase - Output file name base, to write the OSM data to

   Return: Nothing
   """
   # C'Tor with arguments
   def __init__(self, pos1, pos2, outbase):
       # Preprocessing - match coords to box boundaries
       (self._west, self._east, self._north, self._south) = coord_order(pos1, pos2)
       # And store filebase
       self._outbase = outbase

   # Start of with processing
   def __enter__(self):
       # Call to  phyghtmap with default arguments (see opts) and the
       # --area=LEFT:BOTTOM:RIGHT:TOP and -o output_base

       # Then execute it
       try:
           execute_cmd(opts['topo_cmd'], opts['topo_opts'] +
              [ opts['topo_opts_area'].format(west=self._west, east=self._east, north=self._north, south=self._south), 
                opts['topo_opts_hgtcache'].format(dir=opts['topo_hgtcache_dir']),
                opts['topo_opts_output'].format(outbase=self._outbase) ]
              )
       except ExecuteCommandFailed:
           raise    # Error already printed, that's it for us
       except:   # Other error
           perror("   Execution failed!")
           raise

       return self

   # End of with processing - kinda destructor
   def __exit__(self, type, value, traceback):
       pass








# ******************************************************************************
# *** Functions

def relax_float(string):
   """A relaxed float representation, which also understands "," as separator

   For example, both values are equally valid and have the same value:
   123.456 == 123,456

   Return: Float or raises an ArgumentTypeError
   """
   # First try the replacement (in case it's necessary)
   rstring = re.sub(',', '.', string)
   try:  # Now try the conversion
     val = float(rstring)
   except:   # Error, we have failed
       msg = "{0} is no float value".format(string)
       raise argparse.ArgumentTypeError(msg)
   # else we have succeeded
   return val

def execute_cmd(cmd, args):
    """Execute the given command and raises an ExecuteCommandFailed upon failure

    Argument: Command to execute
              Its arguments as list

    Return: Nothing
    """

    # Echo
    pinfo("   Executing " + cmd + " " + " ".join(args) )

    # Execute and print output
    if not opts['test']:  # Not in testmode
        try:
            retcode = subprocess.call([cmd] + args, shell=False)
            if retcode < 0:
                perror("   cmd {0} was terminated by signal {1} ".format(cmd, str(-retcode)))
                raise ExecuteCommandFailed()
            elif retcode > 0:
                perror("   cmd {0} retunred error code {1} ".format(cmd, str(retcode)))
                raise ExecuteCommandFailed()
        except OSError as e:
            perror("   cmd {0} execution failed: {1}".format(cmd, str(e)))
            raise ExecuteCommandFailed()
        except:
            raise   # Other errors are passed further

    # Done
    return


def coord_order(pos1, pos2):
    """Sort the coordinates into the right order

    Arguments: pos1, pos2 - Point1 and Point 2 of coordinates (class Coord)

    Return: Coordinates sorted as
            (west, east, north, south)
    """
    # Preprocessing - match coords to box boundaries
    # west/east
    if pos1.lon > pos2.lon:
        west = pos2.lon
        east = pos1.lon
    else:
        west = pos1.lon
        east = pos2.lon
    # north/south
    if pos1.lat > pos2.lat:
        north = pos1.lat
        south = pos2.lat
    else:
        north = pos2.lat
        south = pos1.lat
    return (west, east, north, south)

def get_osm_data(pos1, pos2, outfile):
    """Download OSM data from a box into a file

    Arguments: pos1, pos2 - Point1 and Point 2 of coordinates (class Coord)
              outfile - Output file name, to write the OSM data to

    Return: Nothing
    """
    # Manual data fetching with OSM (X)API:
    # - Example export from www.openstreetmap.org
    #        47.1916
    # 9.8237		9.8746
    # 	47.1423
    # 
    # - bbox = left,down,right,up
    # 
    # API - Data identical
    # curl --location --globoff -o map-osm-api.osm  'http://api.openstreetmap.org/api/0.6/map?bbox=9.8237,47.1423,9.8746,47.1916'
    # 
    # XAPI - Seems to be reordered compared to API result, but content-wise identical
    # curl --location --globoff -o map-osm-xapi.osm  'http://open.mapquestapi.com/xapi/api/0.6/map?bbox=9.8237,47.1423,9.8746,47.1916'

    # Preprocessing - match coords to box boundaries
    (west, east, north, south) = coord_order(pos1, pos2)
    # The URL constructed
    url_str = opts['xapi_url'].format(west=west, east=east, north=north, south=south)

    # Check for existing outfile - Attention race condition because of later open!
    if os.path.isfile(outfile):
        perror("File " + outfile + " exists already - Aborting")
        raise OutputFileExists

    # Open output file
    try:
        # Open output file - binary write
        if not opts['test']:  # Not in testmode
            out = open(outfile, 'wb')
    except:
        perr('Failing to open output file ' + outfile)
        raise


    try:
        # Open the URL
        pinfo("Fetching OSM data from URL\n   " + url_str)
        pinfo("   and writing it to file " + outfile)
        pinfo("   This will take a while ...")
        if not opts['test']:  # Not in testmode
              url = urllib2.urlopen(url_str)
    except:
        perror('Opening the XAPI-URL failed: ' + url_str )
        raise

    try:
        # Write to file - with nice progress bar thanks to
        # http://stackoverflow.com/questions/22676/how-do-i-download-a-file-over-http-using-python
        if not opts['test']:  # Not in testmode
            out.write(url.read())
            # Progress bar not working as expected because of chunked transfer
            # meta = url.info()
            # print meta
            # file_size = int(meta.getheaders("Content-Length")[0])
            # print file_size
            # return
            # pinfo("   Downloading: {0:s} Bytes: {1:s}".format(file_name, file_size) )
            # file_size_dl = 0
            # block_sz = 8192
            # while True:
            #     buffer = url.read(block_sz)
            #     if not buffer:
            #         break
            # file_size_dl += len(buffer)
            # out.write(buffer)
            # status = r"%10d  [%3.2f%%]" % (file_size_dl, file_size_dl * 100. / file_size)
            # status = status + chr(8)*(len(status)+1)
            # pinfo("   " + status)
    except:
        perror('Reading data and writing to the file failed!')
        raise


    # Cleanup
    if not opts['test']:  # Not in testmode
        url.close()
        out.close()

    # Over and out
    pinfo("   Done!")
    return


def get_topo_data(pos1, pos2, outbase):
    """Create OSM Topographic data from a box into a file

    Arguments: pos1, pos2 - Point1 and Point 2 of coordinates (class Coord)
              outbase - Output file name base, to write the OSM data to

    Return: Nothing
    """

    # Call Sub-Program with the help of a context manager
    pinfo("Creating topographic map data with " + opts['topo_cmd'])
    try:
        with ExecTopoCmd(pos1, pos2, outbase) as topo_tool:
            pass
    except ExecuteCommandFailed:
        # Already consumed, no more printing
        return
    except:
        perror("   Execution failed!")
        raise

    # Over and out
    pinfo("   Done!")
    return


# ********************************************************************************

# *** Main Program
def main():

    # *** Command line parsing
    # cmd_usage="usage: %prog [options] args"
    # For now, just fetch a rectangle by its coordinates
    cmd_desc ="""Download OSM data from a coordinate box
Supply with two set of coorinates (like from Google Map's LatLng marker)
and the box will be fetched from OSM.
When not disabled, also the topographic data will be created
Example: %(prog)s data 61,001 22,758 60.948 22.871
         Yes, both English as well as German notation is allowed"""
    # cmd_desc ="""osmfromtrack - Download OSM data around a GPX track"""
    cmd_version="%(prog)s " + __version__
    cmd_parser = argparse.ArgumentParser(description=cmd_desc,
                 formatter_class=argparse.RawDescriptionHelpFormatter)  # With pre-formatted description
    cmd_parser.add_argument('filebase', help='Output file name base - no suffix please')
    cmd_parser.add_argument('latitude1', type=relax_float, help='Latitude of first point')
    cmd_parser.add_argument('longitude1', type=relax_float, help='Longitude of first point')
    cmd_parser.add_argument('latitude2', type=relax_float, help='Latitude of second point')
    cmd_parser.add_argument('longitude2', type=relax_float, help='Longitude of second point')
    cmd_parser.add_argument('-V', '--version', action='version', version=cmd_version)
    cmd_parser.add_argument('--quiet', '-q', dest='quiet', action='store_true',
                        default=False, help='quiet output')
    cmd_parser.add_argument('--test', '--dry-run', '-t', dest='test', action='store_true',
                        default=False, help='Test mode - only echo commands')
    cmd_parser.add_argument('--no-topo', dest='topo', action='store_false',
                        default=True, help='Do not create a topographic map overlay')
    cmd_parser.add_argument('--hgtdir', dest='hgtdir', action='store',
                        default=None, help='Change hgt cache directory for topographic map overlay, '
                                      'defaults to ' + opts['topo_hgtcache_dir'],
                            metavar="DIRECTORY")
    # Parse - abort on failure
    cmd_line = cmd_parser.parse_args()

    # Setup logging: Show only from warnings when being QUIET
    logging.basicConfig(level=logging.WARNING if cmd_line.quiet else logging.INFO,
                    format="%(message)s")
    # Set test mode
    opts['test'] = cmd_line.test
    # (Un)Set topo map creation
    opts['topo'] = cmd_line.topo
    # Set hgt cache dir
    if cmd_line.hgtdir:
        opts['topo_hgtcache_dir'] = cmd_line.hgtdir

    # Get the data from the OSM XAPI
    get_osm_data( Coord(cmd_line.latitude1, cmd_line.longitude1),
                  Coord(cmd_line.latitude2, cmd_line.longitude2),
                  cmd_line.filebase+".osm")

    # Also fetch the SRTM data when not disabled
    if opts['topo']:
        get_topo_data( Coord(cmd_line.latitude1, cmd_line.longitude1),
                  Coord(cmd_line.latitude2, cmd_line.longitude2),
                  cmd_line.filebase)

    # All done, over and out
    pinfo("All Done!")
    return 0


# *** Call Main program
__version__ = filter(str.isdigit, "$LastChangedRevision$")
if not __version__:
    __version__='DEV'
if __name__ == "__main__":
    main()

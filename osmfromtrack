#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# file name: ''osmfromtrack''
#   project: osmfromtrack
#  function: Download OSM data around a GPX track
#
#      created: 2012-08-18
#  last change: $LastChangedRevision$
#
# Download OSM data from within a coordinate box or gpx track
# Copyright (C) 2012, 2013 Robert Lange (robert.lange@s1999.tu-chemnitz.de)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#



# *** Import modules
# To control output level easily
import logging
# Argument parser
import argparse
# Regular Expressions
import re
# OS operation
import os
# Spawn sub-process
import subprocess
# Fetching OSM Data
import urllib.request
# XML parsing
import xml.etree.ElementTree
# cos
import math


# ******************************************************************************
# *** Global settings as dictionary
opts = { # URL of the XAPI to fetch OSM data from, with its coords west,south,east,north
        # Will be used with format()
        # Outdated and not working anymore?
        # 'xapi_url': 'http://open.mapquestapi.com/xapi/api/0.6/map?bbox={west:f},{south:f},{east:f},{north:f}',
        'xapi_url': 'http://overpass.osm.rambler.ru/cgi/xapi?map?bbox={west:f},{south:f},{east:f},{north:f}',
        # Test mode - only echo commands, will be set by command line
        'test': False,
        # Fetch OSM data - can be unset by command line
        'osm': True,
        # Create Topographic map - can be unset by command line
        'topo': True,
        # Compress files - can be unset by command line
        'compress': True,
        # Default hgt cache directory - can be changed by command line
        'topo_hgtcache_dir': os.path.expanduser("~") + "/.cache/hgt",

        # Command for Topographic Map creation: phyghtmap
        'topo_cmd': 'phyghtmap',
        # Default options for phyghtmap
        'topo_opts': [ "--step=50",
                      "--line-cat=400,100", "--jobs=2", "--viewfinder-mask=1",
                       "--verbatim-output-name" ],    # phyghtmap improvement not to mangle the file name
        # Custom hgt cache directory, will be used with format()
        'topo_opts_hgtcache': '--hgtdir={dir:s}',
        # Area to process, will be used with format()
        'topo_opts_area': '--area={west:f}:{south:f}:{east:f}:{north:f}',
        # Output base file name, will be used with format()
        'topo_opts_output': '-o{outfile:s}',

        # Command for compression with default options: xz
        'compress_cmd': 'xz',

        # Command for inline uncompression with default options: xz
        'uncompress_cmd': [ 'xz', '-d', '--stdout'],
        # Regexp to find compressed file
        'uncompress_match': re.compile('\.xz$'),

        # GPX bounding box: Extra-Distance to fetch in m
        'gpx_margin': 5000,

        # Invoke etrex30 afterwards when not None
        # contains title and shorttitle as array - set by command line
        'etrex_title_shorttitle': None,
        # etrex30 executable
        'etrex_cmd': 'etrex30',
       }

# Provide logging shortcuts
pinfo  = logging.info
pwarn  = logging.warning
perror = logging.error


# ******************************************************************************
# *** Exception Objects - they should be improved to also include the error reason

class OutputFileExists(BaseException):
    """Exception Class for existing output file
    """
    pass
class ExecuteCommandFailed(BaseException):
    """Exception Class for failed program execution
    """
    pass


# ********************************************************************************
# *** Objects

class Coord():
   """GPX coordinates, consisting of longitude and latitude
   """
   # C'Tor with arguments longitude and latitude
   def __init__(self, lat = 0, lon = 0):
       self.lat = lat
       self.lon = lon
   # Latitude
   # lat
   # Longitude
   # lon

class ExecTopoCmd():
   """Execute the topographic map creation tool

   Should be used together with the "with" statement:
        with ExecTopoCmd() as topo_tool:
            pass
   Why "with"? Just for fun and playing around with it ^_^

   C'tor Arguments: pos1, pos2 - Point1 and Point 2 of coordinates (class Coord)
             outfile - Output file name, to write the OSM data to

   Return: Nothing
   """
   # C'Tor with arguments
   def __init__(self, pos1, pos2, outfile):
       # Preprocessing - match coords to box boundaries
       (self._west, self._east, self._north, self._south) = coord_order(pos1, pos2)
       # And store filebase
       self._outfile = outfile

   # Start of with processing
   def __enter__(self):
       # Call to  phyghtmap with default arguments (see opts) and the
       # --area=LEFT:BOTTOM:RIGHT:TOP and -o output_base

       # Then execute it
       try:
           cmd = [ opts['topo_cmd'] ] + opts['topo_opts'] + \
              [ opts['topo_opts_area'].format(west=self._west, east=self._east, north=self._north, south=self._south), 
                opts['topo_opts_hgtcache'].format(dir=opts['topo_hgtcache_dir']),
                opts['topo_opts_output'].format(outfile=self._outfile) ]
           execute_cmd(*cmd)
       except ExecuteCommandFailed:
           raise    # Error already printed, that's it for us
       except:   # Other error
           perror("   Execution failed!")
           raise

       return self

   # End of with processing - kinda destructor
   def __exit__(self, type, value, traceback):
       pass








# ******************************************************************************
# *** Functions

def relax_float(string):
   """A relaxed float representation, which also understands "," as separator

   For example, both values are equally valid and have the same value:
   123.456 == 123,456

   Return: Float or raises an ArgumentTypeError
   """
   # First try the replacement (in case it's necessary)
   rstring = re.sub(',', '.', string)
   try:  # Now try the conversion
     val = float(rstring)
   except:   # Error, we have failed
       msg = "{0} is no float value".format(string)
       raise argparse.ArgumentTypeError(msg)
   # else we have succeeded
   return val

def execute_cmd(*cmd, return_output=False):
    """ *** Execute shell and examine error code
    1.P+: Array of command line call
    return_ouput: When True then the output is returned
                  False: Print it to shell output

    Returns: Command output for return_output=True, None otherwise
    """

    # Create variable, needed for catch
    cmd_out = None
    try:
       # Print command to execute
       pinfo("   " + " ".join(cmd))
       if opts['test']:   # No execution in Testmode
           return 0
       phandler = subprocess.Popen(cmd, \
                      shell=False, stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
       # Catch program output and error out
       cmd_stdout, cmd_stderr = phandler.communicate()
       # Return code
       retcode = phandler.returncode
       # When not keeping program output, throw it away
       if not return_output:
          pinfo(cmd_stdout.decode(encoding))
          pinfo(cmd_stderr.decode(encoding))
          cmd_out = None
       else:
          # Combined output for returning as str
          cmd_out = (cmd_stdout + cmd_stderr).decode()

       if retcode < 0:
           perror("   cmd {0} was terminated by signal {1} ".format(cmd, str(-retcode)))
           raise ExecuteCommandFailed()
       elif retcode > 0:
           perror("   cmd {0} retunred error code {1} ".format(cmd, str(retcode)))
           raise ExecuteCommandFailed()
    except OSError as e:
        perror("   cmd {0} execution failed: {1}".format(cmd, str(e)))
        raise ExecuteCommandFailed()
    except:
       raise   # Other errors are passed further


    return cmd_out   # No error


def coord_order(pos1, pos2):
    """Sort the coordinates into the right order

    Arguments: pos1, pos2 - Point1 and Point 2 of coordinates (class Coord)

    Return: Coordinates sorted as
            (west, east, north, south)
    """
    # Preprocessing - match coords to box boundaries
    # west/east
    if pos1.lon > pos2.lon:
        west = pos2.lon
        east = pos1.lon
    else:
        west = pos1.lon
        east = pos2.lon
    # north/south
    if pos1.lat > pos2.lat:
        north = pos1.lat
        south = pos2.lat
    else:
        north = pos2.lat
        south = pos1.lat
    return (west, east, north, south)

def get_osm_data(pos1, pos2, outfile):
    """Download OSM data from a box into a file

    Arguments: pos1, pos2 - Point1 and Point 2 of coordinates (class Coord)
              outfile - Output file name, to write the OSM data to

    Return: Output file name (can be modified by compression)
    """
    # Manual data fetching with OSM (X)API:
    # - Example export from www.openstreetmap.org
    #        47.1916
    # 9.8237		9.8746
    # 	47.1423
    #
    # - bbox = left,down,right,up
    #
    # API - Data identical
    # curl --location --globoff -o map-osm-api.osm  'http://api.openstreetmap.org/api/0.6/map?bbox=9.8237,47.1423,9.8746,47.1916'
    #
    # XAPI - Seems to be reordered compared to API result, but content-wise identical
    # curl --location --globoff -o map-osm-xapi.osm  'http://open.mapquestapi.com/xapi/api/0.6/map?bbox=9.8237,47.1423,9.8746,47.1916'

    # Preprocessing - match coords to box boundaries
    (west, east, north, south) = coord_order(pos1, pos2)
    # The URL constructed
    url_str = opts['xapi_url'].format(west=west, east=east, north=north, south=south)

    # Check for existing outfile - Attention race condition because of later open!
    if os.path.isfile(outfile):
        perror("File " + outfile + " exists already - Aborting")
        raise OutputFileExists

    # Open output file
    try:
        # Open output file - binary write
        if not opts['test']:  # Not in testmode
            out = open(outfile, 'wb')
    except:
        perr('Failing to open output file ' + outfile)
        raise


    try:
        # Open the URL
        pinfo("Fetching OSM data from URL\n   " + url_str)
        pinfo("   and writing it to file " + outfile)
        pinfo("   This will take a while ...")
        if not opts['test']:  # Not in testmode
              url = urllib.request.urlopen(url_str)
    except:
        perror('Opening the XAPI-URL failed: ' + url_str )
        raise

    try:
        # Write to file - with nice progress bar thanks to
        # http://stackoverflow.com/questions/22676/how-do-i-download-a-file-over-http-using-python
        if not opts['test']:  # Not in testmode
            out.write(url.read())
            # Progress bar not working as expected because of chunked transfer
            # meta = url.info()
            # print meta
            # file_size = int(meta.getheaders("Content-Length")[0])
            # print file_size
            # return
            # pinfo("   Downloading: {0:s} Bytes: {1:s}".format(file_name, file_size) )
            # file_size_dl = 0
            # block_sz = 8192
            # while True:
            #     buffer = url.read(block_sz)
            #     if not buffer:
            #         break
            # file_size_dl += len(buffer)
            # out.write(buffer)
            # status = r"%10d  [%3.2f%%]" % (file_size_dl, file_size_dl * 100. / file_size)
            # status = status + chr(8)*(len(status)+1)
            # pinfo("   " + status)
    except:
        perror('Reading data and writing to the file failed!')
        raise

    # Cleanup
    if not opts['test']:  # Not in testmode
        url.close()
        out.close()

    # Do compression, when requested
    routfile = compress_file(outfile)

    # Over and out
    pinfo("   Done!")
    return routfile

def compress_file(cfile):
    """Compress the specified file when enabled in options

    Arguments: cfile - file to compress in-place

    Return: Output file name (can be modified by compression)
    """

    if not opts['compress']:
        return cfile                         # No compression requested

    # Then execute it
    try:
        execute_cmd(opts['compress_cmd'], cfile )
    except ExecuteCommandFailed:
        raise    # Error already printed, that's it for us
    except:   # Other error
        perror("   Execution failed!")
        raise
    return cfile + ".xz"


def get_topo_data(pos1, pos2, outfile):
    """Create OSM Topographic data from a box into a file

    Arguments: pos1, pos2 - Point1 and Point 2 of coordinates (class Coord)
              outfile - Output file name

    Return: Output file name (can be modified by compression)
    """

    # Call Sub-Program with the help of a context manager
    pinfo("Creating topographic map data with " + opts['topo_cmd'])
    try:
        with ExecTopoCmd(pos1, pos2, outfile) as topo_tool:
            pass
    except ExecuteCommandFailed:
        # Already consumed, no more printing
        return None
    except:
        perror("   Execution failed!")
        raise

    # Check that output file got created
    if not opts['test']:  # Not in testmode
        if not os.path.isfile(outfile):
            perror("Expected output file " + outfile + " did not got created - Aborting")
            raise OutputFilekNotCreated

    # Do compression, when requested
    routfile = compress_file(outfile)

    # Over and out
    pinfo("   Done!")
    return routfile


def invoke_etrex(title, shorttitle, osm, topo):
    """Invokes etrex30 executable for the created files

    Arguments: title      - Map Title, see etrex30
               shorttitle - Map Short Title, see etrex30
               osm        - Filename OSM Data
               topo       - Filename Topographic OSM Data; None when not availabe

    Return: Nothing
    """

    pinfo("Invoking etrex to put files an Garmim device")

    # Build option array
    etrex_opts = []
    if topo is None:
        etrex_opts.append("putosm")  # Only OSM
    else:
        etrex_opts.append("puttopo")  # OSM and Topo

    # OSM Data
    etrex_opts.append(osm)
    if topo is not None:
        etrex_opts.append(topo)        # Also add Topo
    # Title names
    etrex_opts.extend([ title, shorttitle ] )

    # Execute it
    execute_cmd(opts['etrex_cmd'], *etrex_opts )

    # Over and out
    pinfo("   Done!")
    return

# ********************************************************************************
# *** Command line parsing

def parse_commandline():
    """ Command line parsing

    Returns the coordinates or gpx file in a dict; Members
    filebase - Output file base
    mode - either 'gpx' or 'bbox'
    For mode='gpx':
        gpxfile: Input GPX file name
    For mode= 'bbox'
        pos1, pos2: Bounding box coordinates as Coord
    """
    # cmd_usage="usage: %prog [options] args"
    # For now, just fetch a rectangle by its coordinates
    cmd_desc ="""Download OSM data from a coordinate box or around a gpx file track.
When not disabled, also the topographic data will be created.
"""
    # cmd_desc ="""osmfromtrack - Download OSM data around a GPX track"""
    cmd_version="%(prog)s " + __version__
    cmd_parser = argparse.ArgumentParser(description=cmd_desc,
                 formatter_class=argparse.RawDescriptionHelpFormatter)  # With pre-formatted description
    # Default Options
    cmd_parser.add_argument('-V', '--version', action='version', version=cmd_version)
    cmd_parser.add_argument('--quiet', '-q', dest='quiet', action='store_true',
                        default=False, help='quiet output')
    cmd_parser.add_argument('--test', '--dry-run', '-t', dest='test', action='store_true',
                        default=False, help='Test mode - only echo commands')
    cmd_parser.add_argument('--no-osm', dest='osm', action='store_false',
                        default=True, help='Do not download OSM data')
    cmd_parser.add_argument('--no-topo', dest='topo', action='store_false',
                        default=True, help='Do not create a topographic map overlay')
    cmd_parser.add_argument('--no-compress', dest='compress', action='store_false',
                        default=True, help='Do not compress output files with ' + opts['compress_cmd'] )
    cmd_parser.add_argument('--hgtdir', dest='hgtdir', action='store',
                        default=None, help='Change hgt cache directory for topographic map overlay, '
                                      'defaults to ' + opts['topo_hgtcache_dir'],
                            metavar="DIRECTORY")
    cmd_parser.add_argument('-e', '--etrex', '--etrex30', dest='etrex', action='store', nargs=2,
                            default=None,
                            help='Invoke etrex30 with argument osm or topo to put the created files '
                            'on a Garmin eTrex30 device. '
                            'First value is title, second value is shorttitle. See etrex30 help',
                            metavar="VAL")

    # Get object for the sub-parsers
    cmd_subparsers = cmd_parser.add_subparsers(title='Operation Modes',
                        description='Use coordinates or GPX file for bounding box generation.\nGet subcommand help with "%(prog)s subcommand --help"')
    #                   help='additional help')

    # Build sub parser for manual bounding box command
    cmd_bbox_help = """Supply with two set of coordinates (like from Google Map's LatLng marker)
and the box will be fetched from OSM.
Example: %(prog)s data 61,001 22,758 60.948 22.871 - 
         Yes, both English as well as German notation is allowed
"""
    cmd_bbox = cmd_subparsers.add_parser('bbox', help = cmd_bbox_help) # aliases=['coord', 'boundingbox', 'coordinates'],
    cmd_bbox.add_argument('filebase', help='Output file name base - no suffix please')
    cmd_bbox.add_argument('latitude1', type=relax_float, help='Latitude of first point')
    cmd_bbox.add_argument('longitude1', type=relax_float, help='Longitude of first point')
    cmd_bbox.add_argument('latitude2', type=relax_float, help='Latitude of second point')
    cmd_bbox.add_argument('longitude2', type=relax_float, help='Longitude of second point')
    cmd_bbox.set_defaults(cmdmode='bbox')   # Return parser mode

    # Build sub parser for gpx file parsing
    cmd_gpx_help = """Extract the map bounding box from a GPX track file.
The supplied file is read and all track points of the following format are considered:
    <trkpt lat="50.9816789999999" lon="14.075968"/>

- All points are read and a margin of {margin}m in all directions is applied to
calculate the bounding box.

Example Call: %(prog)s data route.gpx
""".format(margin=opts['gpx_margin'])
    cmd_gpx = cmd_subparsers.add_parser('gpx', help = cmd_gpx_help) # aliases=['file']
    cmd_gpx.add_argument('filebase', help='Output file name base - no suffix please')
    cmd_gpx.add_argument('gpxfile', help='Input GPX file')
    cmd_gpx.set_defaults(cmdmode='gpx')   # Return parser mode

    # Parse - abort on failure
    cmd_line = cmd_parser.parse_args()

    # Setup logging: Show only from warnings when being QUIET
    logging.basicConfig(level=logging.WARNING if cmd_line.quiet else logging.INFO,
                    format="%(message)s")
    # Set test mode
    opts['test'] = cmd_line.test
    # (Un)Set OSM download
    opts['osm'] = cmd_line.osm
    # (Un)Set topo map creation
    opts['topo'] = cmd_line.topo
    # (Un)Set topo map creation
    opts['compress'] = cmd_line.compress
    # Set hgt cache dir
    if cmd_line.hgtdir:
        opts['topo_hgtcache_dir'] = cmd_line.hgtdir
    # Set etrex30 arguments
    if cmd_line.etrex:
        opts['etrex_title_shorttitle'] = cmd_line.etrex

    # Assign return values
    rdic = {'mode': cmd_line.cmdmode,
            'filebase': cmd_line.filebase
           }
    if rdic['mode'] == "bbox":
         rdic['pos1']  =  Coord(cmd_line.latitude1, cmd_line.longitude1)
         rdic['pos2']  =  Coord(cmd_line.latitude2, cmd_line.longitude2)
    elif rdic['mode'] == "gpx":
         rdic['gpxfile'] = cmd_line.gpxfile
    else:
       perror("Unknown command line parsing mode found! Something went wrong herre!")
       raise RuntimeError

    # Fertig
    return rdic


# ********************************************************************************
def get_xml_element_by_tag(xml, tag):
    """ Generator for extracting tags by name, without caring about name space

    Arguments:
        xml: xml.etree.ElementTree to examine
        tag: Tag text to filter for

    Returns next yielded XML Element

    Thanks to Stack Overflow for code snippet
    """
    if xml.tag.endswith(tag):
        yield xml
    for child in xml:
        for g in get_xml_element_by_tag(child, tag):
            yield g

def get_bbox_from_gpx(gpxfile, coords):
    """ Extracts a bounding box from a GPX file

    It reads all track points from gpxfile of the following format:
    <trkpt lat="50.9816789999999" lon="14.075968"/>
    All points are read and a margin of opts['gpx_margin'] meter in all directions is
    applied to calculate the bounding box.

    Arguments:
         gpxfile: GPX file to read from
         coords: dict to return values

    Returns the following dict values inside the argument coords
        pos1, pos2: Bounding box coordinates as Coord
    """

    # Open the file and read it in
    pinfo("Extracting bounding box from " + coords['gpxfile'] + " ...")
    # Is it compresssed?
    if opts['uncompress_match'].search(gpxfile):
        # Yes, so we need to uncompress it
        pinfo("   Compressed file found - will uncompress it")
        try:
            cmd = opts['uncompress_cmd']
            cmd.append(gpxfile)
            gpxunc = execute_cmd(*cmd, return_output=True)
        except ExecuteCommandFailed:
            raise    # Error already printed, that's it for us
        except:   # Other error
            perror("   Execution failed!")
            raise
        # Now parse the data
        try:
            xml_content = xml.etree.ElementTree.XML(gpxunc)
        except:   # Error reading XML file
            perror("Error parsing uncompressed GPX file " + gpxfile)
            raise
    else:
        # No compression? Then just read as-is
        try:
            xml_content = xml.etree.ElementTree.parse(gpxfile)
        except:   # Error reading XML file
            perror("Reading GPX file " + gpxfile + "failed!")
            raise

    # Now go through <trkpt> tags and get minimun/maximum for both lat and lon
    lat_max = -999.9
    lon_max = -999.9
    lat_min = +999.9
    lon_min = +999.9
    # Iterate over all <trkpt>
    # Now do the examination
    for trkpt in get_xml_element_by_tag(xml=xml_content.getroot(), tag='trkpt'):
        lat = float(trkpt.attrib['lat'])
        lon = float(trkpt.attrib['lon'])
        # Debug: print("lat={0}, lon={1}".format(lat, lon))
        if lat > lat_max:
            lat_max = lat
        if lat < lat_min:
            lat_min = lat
        if lon > lon_max:
            lon_max = lon
        if lon < lon_min:
            lon_min = lon

    # Basic error check
    assert (lat_max != -999.9) and (lon_max != -999.9) and (lat_min != +999.9) and (lon_min != +999.9)

    # Calculate margins - Thanks to Stack Overflow
    lat_margin = opts['gpx_margin'] * 360.0 / 40008000.0
    lon_margin = opts['gpx_margin'] * 360.0 / ( 40008000.0 * math.cos( (lat_min+lat_max)/2.0) )

    # Assign back - with margin
    coords['pos1']  =  Coord(lat=lat_min-lat_margin, lon=lon_min-lon_margin)
    coords['pos2']  =  Coord(lat=lat_max+lat_margin, lon=lon_max+lon_margin)

    # All done
    return

# ********************************************************************************

# *** Main Program
def main():

    # *** Command line parsing
    coords = parse_commandline()

    # When "gpx" is requested, then we need to fetch the coordinates from the file
    if coords['mode'] == 'gpx':
        # Need to get it from GPX file, yeah
        get_bbox_from_gpx(gpxfile=coords['gpxfile'], coords=coords)
        # Debug         print(coords)

    # Get the data from the OSM XAPI
    filename_osm=None
    if opts['osm']:
        filename_osm = get_osm_data( coords['pos1'], coords['pos2'],
                                     coords['filebase'] + ".osm")

    # Also fetch the SRTM data when not disabled
    filename_topo=None
    if opts['topo']:
        filename_topo = get_topo_data( coords['pos1'], coords['pos2'],
                                       coords['filebase'] + ".topo.osm")

    # Invoke etrex30 when requested
    if opts['etrex_title_shorttitle']:
        # Check for all combinations
        if not opts['osm']:
            # noosm, * - Not allowed
            pwarn("OSM data creation disabled, therefore no garmin Download possible.")
            pwarn("    Ignoring option --etrex")
        elif opts['osm'] and (not opts['topo']):
            # osm, notopo - No Topographic Data
            invoke_etrex( title=opts['etrex_title_shorttitle'][0],
                          shorttitle=opts['etrex_title_shorttitle'][1],
                          osm=filename_osm,
                          topo=None)
        elif opts['osm'] and opts['topo']:
            # osm, topo - Full data available
            invoke_etrex( title=opts['etrex_title_shorttitle'][0],
                          shorttitle=opts['etrex_title_shorttitle'][1],
                          osm=filename_osm,
                          topo=filename_topo)
        else:
            perror("Something wrent wrong, this path should have been a non-entry path")
            raise AssertionError

    # All done, over and out
    pinfo("All Done!")
    return 0


# *** Call Main program
__version__ = ''.join(filter(str.isdigit, "$LastChangedRevision$"))
if not __version__:
    __version__='DEV'
if __name__ == "__main__":
    main()
